use std::fs::read_to_string;
use std::path::Path;
use std::collections::{HashMap, HashSet};

fn read_input(p: impl AsRef<Path>) -> HashMap<String, HashSet<String>> {
    let input = read_to_string(p).expect("Couldn't find input file");
    let mut graph = HashMap::new();

    input.lines()
        .for_each(|l| {
            let mut splits = l.split(":");
            let node = splits.next().expect("Couldn't find first part of line").to_string();
            let edges: HashSet<String> = splits.next().expect("Couldn't find second part of line")
                .split_whitespace()
                .map(String::from)
                .collect();

            graph.insert(node, edges);
        });

    graph
}

fn dfs(graph: &HashMap<String, HashSet<String>>, current: &str, target: &str, path: &mut Vec<String>, results: &mut Vec<Vec<String>>) {
    if current == target {
        results.push(path.clone());
        return;
    }

    if let Some(neighbors) = graph.get(current) {
        for neighbor in neighbors {
            if !path.contains(neighbor) {
                path.push(neighbor.clone());
                dfs(graph, neighbor, target, path, results);
                path.pop();
            }
        }
    }
}

fn main() {
    let input = read_input("../input");

    let start_node = "you";
    let end_node = "out";
    
    let mut completed_paths: Vec<Vec<String>> = Vec::new();
    let mut current_path: Vec<String> = Vec::new();
    current_path.push("you".to_string());
    dfs(&input, start_node, end_node, &mut current_path, &mut completed_paths);

    println!("{:?}", completed_paths.len());

    completed_paths.clear();
    current_path.clear();
    
    let start_node = "svr";
    current_path.push("you".to_string());
    dfs(&input, start_node, end_node, &mut current_path, &mut completed_paths);

    completed_paths.iter().filter(|&p| p.contains("dac") && p.contains("fft"))
}
